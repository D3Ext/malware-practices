package main

/*

Author: D3Ext
Blog post: https://d3ext.github.io/posts/malware-dev-6/

*/

import (
  "os"
  "log"
  "fmt"
  "net"
  "unsafe"
  "syscall"
  "os/user"
  "runtime"
  "strings"
  "net/http"

  "golang.org/x/sys/windows"
)

type MemStatusEx struct { // Auxiliary struct to retrieve total memory
  dwLength     uint32
  dwMemoryLoad uint32
  ullTotalPhys uint64
  ullAvailPhys uint64
  unused       [5]uint64
}

type WindowsProcess struct {
  ProcessID       int     // PID
  ParentProcessID int
  Exe             string  // Cmdline executable
}

func GetProcesses() ([]WindowsProcess, error) {
  handle, err := windows.CreateToolhelp32Snapshot(0x00000002, 0)
  if err != nil {
    return nil, err
  }
  defer windows.CloseHandle(handle)
  var entry windows.ProcessEntry32
  entry.Size = uint32(unsafe.Sizeof(entry))

  err = windows.Process32First(handle, &entry)
  if err != nil {
    return nil, err
  }

  results := make([]WindowsProcess, 0, 50)
  for {
    results = append(results, NewWindowsProcess(&entry))

    err = windows.Process32Next(handle, &entry)
    if err != nil {
      if err == syscall.ERROR_NO_MORE_FILES {
        return results, nil
      }
      return nil, err
    }
  }
}

// Auxiliary function

func NewWindowsProcess(e *windows.ProcessEntry32) WindowsProcess {
  end := 0
  for {
    if e.ExeFile[end] == 0 {
      break
    }
    end++
  }

  return WindowsProcess{
    ProcessID:       int(e.ProcessID),
    ParentProcessID: int(e.ParentProcessID),
    Exe:             syscall.UTF16ToString(e.ExeFile[:end]),
  }
}

func main(){
  fmt.Println("[+] Sandboxing checks:")

  // Check disk storage
  fmt.Println("Disk storage")
  GetDiskFreeSpaceExW := windows.NewLazyDLL("kernel32.dll").NewProc("GetDiskFreeSpaceExW")
  lpTotalNumberOfBytes := int64(0)
  diskret, _, err := GetDiskFreeSpaceExW.Call(
    uintptr(unsafe.Pointer(windows.StringToUTF16Ptr("C:\\"))),
    uintptr(0),
    uintptr(unsafe.Pointer(&lpTotalNumberOfBytes)),
    uintptr(0),
  )
  
  if diskret == 0 {
    log.Fatal(err)
  }

  // Less than 64 GB
  if int(lpTotalNumberOfBytes) < 68719476736 {
    os.Exit(0)
  }

  // Check CPU cores
  fmt.Println("CPU cores")
  if runtime.NumCPU() < 2 {
    os.Exit(0)
  }

  // Check RAM memory size
  fmt.Println("RAM memory size")
  msx := &MemStatusEx{
    dwLength: 64,
  }

  GlobalMemoryStatusEx := windows.NewLazyDLL("kernel32").NewProc("GlobalMemoryStatusEx")
  r1, _, err := GlobalMemoryStatusEx.Call(uintptr(unsafe.Pointer(msx)))
  if r1 == 0 {
    log.Fatal(err)
  }

  if int(msx.ullTotalPhys) < 4174967296 {
    os.Exit(0)
  }

  // Check common virtualization drivers
  fmt.Println("Virtualization drivers")
  drivers := []string{"C:\\Windows\\System32\\drivers\\VBoxMouse.sys","C:\\Windows\\System32\\drivers\\VBoxGuest.sys","C:\\Windows\\System32\\drivers\\VBoxSF.sys","C:\\Windows\\System32\\drivers\\VBoxVideo.sys","C:\\Windows\\System32\\vboxdisp.dll","C:\\Windows\\System32\\vboxhook.dll","C:\\Windows\\System32\\vboxmrxnp.dll","C:\\Windows\\System32\\vboxogl.dll","C:\\Windows\\System32\\vboxoglarrayspu.dll","C:\\Windows\\System32\\vboxservice.exe","C:\\Windows\\System32\\vboxtray.exe","C:\\Windows\\System32\\VBoxControl.exe","C:\\Windows\\System32\\drivers\\vmmouse.sys","C:\\Windows\\System32\\drivers\\vmhgfs.sys","C:\\Windows\\System32\\drivers\\vmci.sys","C:\\Windows\\System32\\drivers\\vmmemctl.sys","C:\\Windows\\System32\\drivers\\vmmouse.sys","C:\\Windows\\System32\\drivers\\vmrawdsk.sys","C:\\Windows\\System32\\drivers\\vmusbmouse.sys"}
  for _, d := range drivers { // Iterate over all drivers to check if they exist
    _, err = os.Stat(d)
    if (os.IsNotExist(err) == false) {
      os.Exit(0)
    }
  }

  // Check processes name
  fmt.Println("Virtualization processes")
  vm_proccesses := []string{"vboxservice.exe","vboxtray.exe","vmtoolsd.exe","vmwaretray.exe","vmware.exe","vmware-vmx.exe", "vmwareuser","VGAuthService.exe","vmacthlp.exe","vmsrvc.exe","vmusrvc.exe","xenservice.exe","qemu-ga.exe","wireshark.exe","Procmon.exe","Procmon64.exe","volatily.exe","volatily3.exe","DumpIt.exe","dumpit.exe"}
  processes, err := GetProcesses()
  if err != nil {
    log.Fatal(err)
  }

  for _, p := range processes {
    for _, p_name := range vm_proccesses {
      if p.Exe == p_name {
        os.Exit(0)
      }
    }
  }

  // Check processes amount
  fmt.Println("Processes total amount")
  if len(processes) <= 15 {
    os.Exit(0)
  }

  // Check fake domain (doesn't exist)
  fmt.Println("Modified DNS")
  resp, err := http.Get("https://this-is-a-fake-domain.com")
  if err != nil {
    log.Fatal(err)
  }

  if resp.StatusCode == 200 {
    os.Exit(0)
  }

  // Check self PE name
  fmt.Println("Filename")
  _, path, _, ok := runtime.Caller(1)
  if ok {
    path_array := strings.Split(path, "\\")
    file := path_array[len(path_array)-1]

    mal_names := []string{"sample.exe","malware.exe","virus.exe"}
    for _, f := range mal_names {
      if strings.ToLower(file) == f {
        os.Exit(0)
      }
    }
  }

  // Check username
  fmt.Println("Username")
  u, err := user.Current()
  if err != nil {
    log.Fatal(err)
  }

  known_usernames := []string{"trans_iso_0","analysis","sandbox","debug4fun","j.yoroi","Virtual","user1","Cuckoofork","JujuBox"}
  for _, name := range known_usernames {
    if u.Username == name { // Check if any name match
      os.Exit(0)
    }
  }

  // Check MAC address
  fmt.Println("MAC address")
  ifaces, err := net.Interfaces()
  if err != nil {
    log.Fatal(err)
  }

  // Known virtualization vendor MAC prefixes
  known_macs := []string{"00:50:56","00:0C:29","00:05:69","00:1C:14","08:00:27","52:54:00","00:21:F6","00:0F:4B","00:14:4F"}
  for _, i := range ifaces {
    for _, mac := range known_macs {
      pc_mac := i.HardwareAddr.String()
      
      if strings.Contains(strings.ToUpper(pc_mac), mac) == true {
        os.Exit(0)
      }
    }
  }

  // Check hostname
  fmt.Println("Hostname")
  hostname, err := os.Hostname()
  if err != nil {
    log.Fatal(err)
  }

  known_hostnames := []string{"sandbox","analysis","vmware","vbox","qemu","virustotal","cuckoofork"}
  for _, h := range known_hostnames {
    if hostname == h {
      os.Exit(0)
    }
  }
}



