package main

/*

Author: D3Ext
Blog post: https://d3ext.github.io/posts/malware-analysis-1/

*/

import (
  "os"
  "io"
  "fmt"
  "log"
  "time"
  "flag"
  "math"
  "strings"
  "io/ioutil"
  "crypto/md5"
  "crypto/sha1"
  "crypto/sha256"
  "encoding/hex"
  "encoding/binary"

  // Used to parse PE files
  "github.com/Binject/debug/pe"
)

// Some vars to check PE type
var (
  sizeofOptionalHeader32 = uint16(binary.Size(pe.OptionalHeader32{}))
  sizeofOptionalHeader64 = uint16(binary.Size(pe.OptionalHeader64{}))
)

// Print banner
func Banner(){
  fmt.Println(" ____  _____ ____")
  fmt.Println("|  _ \\| ____|  _ \\ __ _ _ __ ___  ___ _ __ ")
  fmt.Println("| |_) |  _| | |_) / _` | '__/ __|/ _ \\ '__| ")
  fmt.Println("|  __/| |___|  __/ (_| | |  \\__ \\  __/ |   ")
  fmt.Println("|_|   |_____|_|   \\__,_|_|  |___/\\___|_|\n ")
}

func main(){
  var file string
  var verbose bool

  // Create CLI args
  flag.StringVar(&file, "f", "", "path to PE file to parse and analyze")
  flag.BoolVar(&verbose, "v", false, "enable verbose")
  flag.Parse()
  time.Sleep(200 * time.Millisecond)

  if file == "" {
    Banner()
    fmt.Println("Usage: .\\main.exe -f malware.exe")
    flag.PrintDefaults()
    os.Exit(0)
  }

  Banner()
  // Parse PE structure
  pe_file, err := pe.Open(file)
  if err != nil {
    log.Fatal(err)
  }
  // Close file
  defer pe_file.Close()

  if verbose {
    fmt.Println("[*] Determining file type...")
  }

  // Check PE type (PE32 or PE32+)
  var opt_header32 *pe.OptionalHeader32
  var opt_header64 *pe.OptionalHeader64
  var opt32 bool

  if pe_file.FileHeader.SizeOfOptionalHeader == sizeofOptionalHeader32 {
    fmt.Println("[+] PE type: PE32\n")
    opt_header32, _ = pe_file.OptionalHeader.(*pe.OptionalHeader32)
    opt32 = true
  } else if pe_file.FileHeader.SizeOfOptionalHeader == sizeofOptionalHeader64 {
    fmt.Println("[+] PE type: PE32+\n")
    opt_header64, _ = pe_file.OptionalHeader.(*pe.OptionalHeader64)
    opt32 = false
  } else {
    fmt.Println("[-] Error recognizing PE type!")
    os.Exit(0)
  }
  time.Sleep(200 * time.Millisecond)

  // file handle
  f, _ := os.Open(file)
  defer f.Close()

  // md5 hash
  md5_h := md5.New()
  _, err = io.Copy(md5_h, f)
  hashInBytes := md5_h.Sum(nil)
  fmt.Println("[*] MD5 hash:", hex.EncodeToString(hashInBytes))

  // sha1 hash
  sha1_h := sha1.New()
  _, err = io.Copy(sha1_h, f)
  hashInBytes = sha1_h.Sum(nil)
  fmt.Println("[*] Sha-1 hash:", hex.EncodeToString(hashInBytes))

  // sha256 hash
  sha256_h := sha256.New()
  _, err = io.Copy(sha1_h, f)
  hashInBytes = sha256_h.Sum(nil)
  fmt.Println("[*] Sha-256 hash:", hex.EncodeToString(hashInBytes), "\n")

  f2, _ := os.Open(file)
  defer f2.Close()

  contents, err := ioutil.ReadAll(f2)
  if err != nil {
    log.Fatal(err)
  }

  freq := make(map[byte]int)
  for _, b := range contents {
    freq[b]++
  }

  totalBytes := len(contents)
  probs := make(map[byte]float64)
  for b, f := range freq {
    probs[b] = float64(f) / float64(totalBytes)
  }

  entropy := 0.0
  for _, p := range probs {
    if p > 0 {
      entropy -= p * math.Log2(p)
    }
  }

  fmt.Println("[*] File entropy:", entropy, "\n")

  time.Sleep(200 * time.Millisecond)
  if verbose {
    fmt.Println("[*] Parsing DOS header...")
  }

  // DOS Header info
  var dos_check string
  if pe_file.DosExists == true {
    dos_check = "Yes"
  } else {
    dos_check = "No"
  }

  fmt.Println("[+] DOS Header:")
  fmt.Println("  Is header present?:", dos_check)

  fmt.Printf("  Magic: 0x%X\n", pe_file.DosHeader.MZSignature)
  fmt.Printf("  New exe header addr: 0x%X\n", pe_file.DosHeader.AddressOfNewExeHeader)

  // If verbose flag is especified
  // more DOS header info is printed
  if verbose {
    fmt.Printf("  File size in pages: 0x%X\n", pe_file.DosHeader.FileSizeInPages)
    fmt.Printf("  Checksum: 0x%X\n", pe_file.DosHeader.CheckSum)
    fmt.Printf("  Overlay number: 0x%X\n", pe_file.DosHeader.OverlayNumber)
    fmt.Printf("  Relocation table addr: 0x%X\n", pe_file.DosHeader.AddressOfRelocationTable)
  }
  fmt.Println()

  time.Sleep(200 * time.Millisecond)
  // DOS Stub in column format
  fmt.Println("[+] DOS Stub:")
  fmt.Print("  ")
  for i, b := range pe_file.DosStub {
    if (i + 1) % 5 == 0 {
      fmt.Printf("0x%X\n  ", b)
    } else {
      fmt.Printf("0x%X, ", b)
    }
  }
  fmt.Println("\n")

  time.Sleep(200 * time.Millisecond)
  if verbose {
    fmt.Println("[*] Parsing Rich header...")
  }

  if len(pe_file.RichHeader) == 0 {
    fmt.Println("[+] Rich Header not found\n")
  } else {
    fmt.Println("[+] Rich Header:")
    // Rich header bytes
    fmt.Print("  ")
    for i, b := range pe_file.RichHeader {
      // Print it in columns
      if (i + 1) % 5 == 0 {
        fmt.Printf("0x%X\n  ", b)
      } else {
        fmt.Printf("0x%X, ", b)
      }
    }
  }

  time.Sleep(200 * time.Millisecond)
  if verbose {
    fmt.Println("[*] Parsing File header...")
  }

  // File header part
  fmt.Println("[+] File Header:")
  fmt.Printf("  Machine: 0x%X\n", pe_file.FileHeader.Machine)
  fmt.Printf("  Number of sections: 0x%X\n", pe_file.FileHeader.NumberOfSections)

  if verbose { // Print more info if verbose flag is enable
    fmt.Printf("  Timestamp: 0x%X\n", pe_file.FileHeader.TimeDateStamp)
    fmt.Printf("  Symbol table pointer: 0x%X\n", pe_file.FileHeader.PointerToSymbolTable)
    fmt.Printf("  Number of symbols: 0x%X\n", pe_file.FileHeader.NumberOfSymbols)
    fmt.Printf("  Characteristics: 0x%X\n", pe_file.FileHeader.Characteristics)
  }
  fmt.Println()

  time.Sleep(200 * time.Millisecond)
  if verbose {
    fmt.Println("[*] Parsing Optional header...")
  }

  fmt.Println("[+] Optional Header:")
  // Check if optional header is 32 or 64
  if opt32 == true {
    fmt.Printf("  Magic: 0x%X\n", opt_header32.Magic)
    fmt.Printf("  Code size: 0x%X\n", opt_header32.SizeOfCode)
    fmt.Printf("  Checksum: 0x%X\n", opt_header32.CheckSum)

    if verbose {
      fmt.Printf("  Initialized data size: 0x%X\n", opt_header32.SizeOfInitializedData)
      fmt.Printf("  Uninitialized data size: 0x%X\n", opt_header32.SizeOfUninitializedData)
      fmt.Printf("  Entry point addr: 0x%X\n", opt_header32.AddressOfEntryPoint)
      fmt.Printf("  Code base: 0x%X\n", opt_header32.BaseOfCode)
      fmt.Printf("  Image base: 0x%X\n", opt_header32.ImageBase)
      fmt.Printf("  File alignment: 0x%X\n", opt_header32.FileAlignment)
    }
  } else {
    fmt.Printf("  Magic: 0x%X\n", opt_header64.Magic)
    fmt.Printf("  Code size: 0x%X\n", opt_header64.SizeOfCode)
    fmt.Printf("  Checksum: 0x%X\n", opt_header64.CheckSum)

    if verbose {
      fmt.Printf("  Initialized data size: 0x%X\n", opt_header64.SizeOfInitializedData)
      fmt.Printf("  Uninitialized data size: 0x%X\n", opt_header64.SizeOfUninitializedData)
      fmt.Printf("  Entry point addr: 0x%X\n", opt_header64.AddressOfEntryPoint)
      fmt.Printf("  Code base: 0x%X\n", opt_header64.BaseOfCode)
      fmt.Printf("  Image base: 0x%X\n", opt_header64.ImageBase)
      fmt.Printf("  File alignment: 0x%X\n", opt_header64.FileAlignment)
    }
  }
  fmt.Println()

  if verbose {
    fmt.Println("[*] Parsing section headers...")
  }

  fmt.Println("[+] Section headers:")
  fmt.Println("  Amount of sections:", len(pe_file.Sections), "\n")

  for _, s := range pe_file.Sections {
    fmt.Println("  - Name:", s.SectionHeader.Name)
    fmt.Printf("    Virtual addr: 0x%X\n", s.SectionHeader.VirtualAddress)
    fmt.Printf("    Virtual size: 0x%X\n", s.SectionHeader.VirtualSize)
    fmt.Printf("    Raw data size: 0x%X\n", s.SectionHeader.Size)
    
    if verbose {
      fmt.Printf("    Characteristics: 0x%X\n", s.SectionHeader.Characteristics)
    }
    fmt.Println()
  }

  time.Sleep(200 * time.Millisecond)
  // Extract imported DLLs and functions from IAT
  fmt.Println("[+] Import Table:\n")
  iat, _, _, err := pe_file.ImportDirectoryTable()
  if err != nil {
    log.Fatal(err)
  }

  symbols, err := pe_file.ImportedSymbols()
  if err != nil {
    log.Fatal(err)
  }

  for _, imp := range iat {
    fmt.Println("  DLL:", imp.DllName)
    fmt.Printf("  ILT RVA: 0x%X\n", imp.OriginalFirstThunk)
    fmt.Printf("  IAT RVA: 0x%X\n", imp.FirstThunk)

    if verbose {
      fmt.Printf("  Name RVA: 0x%X\n", imp.NameRVA)
    }
    fmt.Println("  Entries:")

    for _, s := range symbols {
      if strings.Split(s, ":")[1] == imp.DllName {
        fmt.Println("    " + strings.Split(s, ":")[0])
      }
    }
    fmt.Println()
  }

  time.Sleep(200 * time.Millisecond)

  fmt.Println("[+] Relocation Table:")
  reloc_table := pe_file.BaseRelocationTable
  fmt.Printf("  Number of entries: 0x%X\n", len(*reloc_table))
  fmt.Println("  Entries:\n")

  for _, s := range *reloc_table {
    time.Sleep(50 * time.Millisecond)
    fmt.Printf("    Virtual Addr: 0x%X\n", s.RelocationBlock.VirtualAddress)
    fmt.Printf("    Size: 0x%X\n", s.RelocationBlock.SizeOfBlock)
    fmt.Printf("    Type: 0x%X\n\n", s.BlockItems[0].Type)
  }

  fmt.Println("\n[+] Scan completed")
}


