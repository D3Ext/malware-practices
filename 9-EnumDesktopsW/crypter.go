package main

import (
  "os"
  "io"
  "fmt"
  "log"
  "flag"
  "bytes"
  "io/ioutil"
  "crypto/aes"
  "crypto/rand"
  "crypto/cipher"
)

func main(){
  var file string
  var output string
  var key string

  flag.StringVar(&file, "f", "", "raw shellcode file to encrypt")
  flag.StringVar(&output, "o", "", "file to store encrypted shellcode into")
  flag.StringVar(&key, "k", "ExampleKey123456", "16 bytes encryption key")
  flag.Parse()

  if (file == "" || output == "") {
    fmt.Println("Usage: ./crypter -f shellcode.raw -o shellcode.enc -p ExampleKey123456\n")
    flag.PrintDefaults()
    os.Exit(0)
  }

  pass := []byte(key)

  fmt.Println("[*] Encrypting shellcode from " + file)

  text, err := ioutil.ReadFile(file)
  if err != nil {
    log.Fatal(err)
  }

	// Init Cipher
  block, err := aes.NewCipher(pass)
  if err != nil {
    log.Fatal(err)
	}

  // Padding
  padLen := aes.BlockSize - (len(text) % aes.BlockSize)
  padText := bytes.Repeat([]byte{byte(padLen)}, padLen)
  textWithPadding := append(text, padText...)

  // Generate an IV
  ciphertext := make([]byte, aes.BlockSize+len(textWithPadding))
  iv := ciphertext[:aes.BlockSize]

  // Randomness
  _, err = io.ReadFull(rand.Reader, iv)
  if err != nil {
    log.Fatal(err)
  }
  fmt.Println("[*] IV:", iv)

	cfbEncrypter := cipher.NewCFBEncrypter(block, iv)
	cfbEncrypter.XORKeyStream(ciphertext[aes.BlockSize:], textWithPadding)

  err = os.WriteFile(output, ciphertext, 0644)
  if err != nil {
    log.Fatal(err)
  }

  fmt.Println("[+] Encrypted shellcode:")

  for _, b := range ciphertext {
    fmt.Printf("0x%X, ", b)
  }

  fmt.Println("\n[+] Encrypted shellcode written to " + output)
}


